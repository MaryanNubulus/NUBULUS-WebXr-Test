<!DOCTYPE html>
<html lang="ca">
  <head>
    <meta charset="UTF-8" />
    <title>AR Geolocalitzat amb Indicador</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
        font-family: sans-serif;
      }
      #videoBackground {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: 0;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        z-index: 100;
        background: rgba(0, 0, 0, 0.7);
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        max-width: 90%;
      }
      /* Indicador eliminat - ja no √©s necessari */
      .btn {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 30px;
        font-size: 18px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        z-index: 100;
        color: white;
      }
      #geoBtn {
        top: 40%;
        background: #007bff;
      }
      #camBtn {
        top: 50%;
        background: #28a745;
        display: none;
      }
      canvas {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <video id="videoBackground" autoplay playsinline muted></video>
    <div id="info">Prem els botons per activar AR</div>
    <button id="geoBtn" class="btn">Activa Geolocalitzaci√≥</button>
    <button id="camBtn" class="btn">Activa C√†mera</button>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      
      let scene, camera, renderer, model;
      let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
      let screenOrientation = 0;
      let userPosition = null;
      const targetLat = 41.631736995249575;
      const targetLon = 0.7782826945720215;
      const visibilityDistance = 50; // metres (augmentat per millor testing)

      const info = document.getElementById("info");
      const geoBtn = document.getElementById("geoBtn");
      const camBtn = document.getElementById("camBtn");
      const videoElement = document.getElementById("videoBackground");

      // --- PAS 1: Geolocalitzaci√≥ ---
      geoBtn.addEventListener("click", () => {
        navigator.geolocation.watchPosition(
          (pos) => {
            userPosition = pos.coords;
            console.log(
              `üìç Posici√≥: ${pos.coords.latitude.toFixed(6)}, ${pos.coords.longitude.toFixed(6)}`
            );
          },
          (err) => {
            info.innerText = "Perm√≠s GPS denegat";
            console.error(err);
          },
          {
            enableHighAccuracy: true,
            maximumAge: 1000,
            timeout: 5000,
          }
        );

        info.innerText = "Geolocalitzaci√≥ activada!";
        geoBtn.style.display = "none";
        camBtn.style.display = "block";
      });

      // --- PAS 2: C√†mera i Orientaci√≥ ---
      camBtn.addEventListener("click", async () => {
        camBtn.style.display = "none";
        info.innerText = "Iniciant c√†mera i sensors...";

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment" },
            audio: false,
          });
          videoElement.srcObject = stream;

          // Demanar permisos per a DeviceOrientation (necessari per iOS 13+)
          if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
              const permission = await DeviceOrientationEvent.requestPermission();
              if (permission === 'granted') {
                console.log("‚úÖ Perm√≠s d'orientaci√≥ concedit");
              } else {
                info.innerText = "‚ö†Ô∏è Perm√≠s d'orientaci√≥ denegat";
              }
            } catch (err) {
              console.error("Error demanant perm√≠s d'orientaci√≥:", err);
            }
          }

          // Escoltar events d'orientaci√≥ del dispositiu
          window.addEventListener('deviceorientation', (event) => {
            deviceOrientation.alpha = event.alpha || 0; // Rotaci√≥ al voltant de l'eix Z (0-360)
            deviceOrientation.beta = event.beta || 0;   // Rotaci√≥ al voltant de l'eix X (-180 a 180)
            deviceOrientation.gamma = event.gamma || 0; // Rotaci√≥ al voltant de l'eix Y (-90 a 90)
          });

          // Escoltar canvis d'orientaci√≥ de la pantalla
          window.addEventListener('orientationchange', () => {
            screenOrientation = window.orientation || 0;
          });

          info.innerText = "‚úÖ AR iniciada - Mou el dispositiu";

          initAR();
          animate();
        } catch (err) {
          info.innerText = "Error: " + err.message;
          console.error(err);
        }
      });

      function initAR() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ 
          antialias: true, 
          alpha: true // Fons transparent per veure el v√≠deo
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0); // Transparent
        document.body.appendChild(renderer.domElement);

        // Il¬∑luminaci√≥ millorada per iPhone
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemisphereLight);

        // Carregar model GLB
        const loader = new GLTFLoader();
        loader.load(
          "test.glb",
          (gltf) => {
            model = gltf.scene;
            
            // Posicionar l'objecte DAVANT de la c√†mera per defecte
            model.position.set(0, 0, -10); // 10 metres davant
            model.scale.set(2, 2, 2);
            
            // Assegurar que el model t√© materials visibles
            model.traverse((child) => {
              if (child.isMesh) {
                // For√ßar que el material sigui visible
                child.material.side = THREE.DoubleSide;
                child.material.needsUpdate = true;
                
                // Si no t√© material, afegir-ne un de b√†sic
                if (!child.material) {
                  child.material = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    side: THREE.DoubleSide
                  });
                }
              }
            });
            
            scene.add(model);
            console.log("‚úÖ Model GLB carregat i posicionat");
            console.log("üì¶ Posici√≥ model:", model.position);
            console.log("üìè Escala model:", model.scale);
          },
          (progress) => {
            const percent = (progress.loaded / progress.total) * 100;
            console.log(`Carregant model: ${percent.toFixed(0)}%`);
          },
          (error) => {
            console.error("‚ùå Error carregant model GLB:", error);
            info.innerText = "Error: No s'ha pogut carregar el model 3D";
          }
        );

        window.addEventListener("resize", onWindowResize);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Converteix lat/lon a metres respecte a l'usuari
      function latLonToMeters(userLat, userLon, objLat, objLon) {
        const R = 6371000;
        const dLat = ((objLat - userLat) * Math.PI) / 180;
        const dLon = ((objLon - userLon) * Math.PI) / 180;
        const latRad = (userLat * Math.PI) / 180;
        const x = dLon * R * Math.cos(latRad);
        const z = dLat * R;
        return { x, z };
  <body>
    <video id="videoBackground" autoplay playsinline muted></video>
    <div id="info">Prem els botons per activar AR</div>
    <button id="geoBtn" class="btn">Activa Geolocalitzaci√≥</button>
    <button id="camBtn" class="btn">Activa C√†mera</button>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      
      let scene, camera, renderer, model;
      let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
      let screenOrientation = 0;
      let userPosition = null;
      const targetLat = 41.631736995249575;
      const targetLon = 0.7782826945720215;
      const visibilityDistance = 50; // metres (augmentat per millor testing)

      const info = document.getElementById("info");
      const geoBtn = document.getElementById("geoBtn");
      const camBtn = document.getElementById("camBtn");
      const videoElement = document.getElementById("videoBackground");

      // --- PAS 1: Geolocalitzaci√≥ ---
      geoBtn.addEventListener("click", () => {
        navigator.geolocation.watchPosition(
          (pos) => {
            userPosition = pos.coords;
            console.log(
              `üìç Posici√≥: ${pos.coords.latitude.toFixed(6)}, ${pos.coords.longitude.toFixed(6)}`
            );
          },
          (err) => {
            info.innerText = "Perm√≠s GPS denegat";
            console.error(err);
          },
          {
            enableHighAccuracy: true,
            maximumAge: 1000,
            timeout: 5000,
          }
        );

        info.innerText = "Geolocalitzaci√≥ activada!";
        geoBtn.style.display = "none";
        camBtn.style.display = "block";
      });

      // --- PAS 2: C√†mera i Orientaci√≥ ---
      camBtn.addEventListener("click", async () => {
        camBtn.style.display = "none";
        info.innerText = "Iniciant c√†mera i sensors...";

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment" },
            audio: false,
          });
          videoElement.srcObject = stream;

          // Demanar permisos per a DeviceOrientation (necessari per iOS 13+)
          if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
              const permission = await DeviceOrientationEvent.requestPermission();
              if (permission === 'granted') {
                console.log("‚úÖ Perm√≠s d'orientaci√≥ concedit");
              } else {
                info.innerText = "‚ö†Ô∏è Perm√≠s d'orientaci√≥ denegat";
              }
            } catch (err) {
              console.error("Error demanant perm√≠s d'orientaci√≥:", err);
            }
          }

          // Escoltar events d'orientaci√≥ del dispositiu
          window.addEventListener('deviceorientation', (event) => {
            deviceOrientation.alpha = event.alpha || 0; // Rotaci√≥ al voltant de l'eix Z (0-360)
            deviceOrientation.beta = event.beta || 0;   // Rotaci√≥ al voltant de l'eix X (-180 a 180)
            deviceOrientation.gamma = event.gamma || 0; // Rotaci√≥ al voltant de l'eix Y (-90 a 90)
          });

          // Escoltar canvis d'orientaci√≥ de la pantalla
          window.addEventListener('orientationchange', () => {
            screenOrientation = window.orientation || 0;
          });

          info.innerText = "‚úÖ AR iniciada - Mou el dispositiu";

          initAR();
          animate();
        } catch (err) {
          info.innerText = "Error: " + err.message;
          console.error(err);
        }
      });

      function initAR() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ 
          antialias: true, 
          alpha: true // Fons transparent per veure el v√≠deo
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0); // Transparent
        document.body.appendChild(renderer.domElement);

        // Il¬∑luminaci√≥ millorada per iPhone
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemisphereLight);

        // Carregar model GLB
        const loader = new GLTFLoader();
        loader.load(
          "test.glb",
          (gltf) => {
            model = gltf.scene;
            
            // Posicionar l'objecte DAVANT de la c√†mera per defecte
            model.position.set(0, 0, -10); // 10 metres davant
            model.scale.set(2, 2, 2);
            
            // Assegurar que el model t√© materials visibles
            model.traverse((child) => {
              if (child.isMesh) {
                // For√ßar que el material sigui visible
                child.material.side = THREE.DoubleSide;
                child.material.needsUpdate = true;
                
                // Si no t√© material, afegir-ne un de b√†sic
                if (!child.material) {
                  child.material = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    side: THREE.DoubleSide
                  });
                }
              }
            });
            
            scene.add(model);
            console.log("‚úÖ Model GLB carregat i posicionat");
            console.log("üì¶ Posici√≥ model:", model.position);
            console.log("üìè Escala model:", model.scale);
          },
          (progress) => {
            const percent = (progress.loaded / progress.total) * 100;
            console.log(`Carregant model: ${percent.toFixed(0)}%`);
          },
          (error) => {
            console.error("‚ùå Error carregant model GLB:", error);
            info.innerText = "Error: No s'ha pogut carregar el model 3D";
          }
        );

        window.addEventListener("resize", onWindowResize);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Converteix lat/lon a metres respecte a l'usuari
      function latLonToMeters(userLat, userLon, objLat, objLon) {
        const R = 6371000;
        const dLat = ((objLat - userLat) * Math.PI) / 180;
        const dLon = ((objLon - userLon) * Math.PI) / 180;
        const latRad = (userLat * Math.PI) / 180;
        const x = dLon * R * Math.cos(latRad);
        const z = dLat * R;
        return { x, z };
      }

      function animate() {
        requestAnimationFrame(animate);

        // Aplicar rotaci√≥ de la c√†mera basada en l'orientaci√≥ del dispositiu
        updateCameraOrientation();

        if (userPosition && model) {
          const meters = latLonToMeters(
            userPosition.latitude,
            userPosition.longitude,
            targetLat,
            targetLon
          );
          
          // Calcular dist√†ncia real total
          const distance = Math.sqrt(meters.x ** 2 + meters.z ** 2);
          
          // Posicionar l'objecte SEMPRE centrat davant del dispositiu
          // Nom√©s varia la dist√†ncia (eix Z)
          model.position.x = 0;
          model.position.y = 0;
          model.position.z = -distance; // Negatiu perqu√® est√† davant
          
          model.visible = distance <= visibilityDistance;

          // Informaci√≥ de debug simplificada
          const accuracy = userPosition.accuracy ? userPosition.accuracy.toFixed(1) : 'N/A';
          info.innerHTML = model.visible
            ? `‚úÖ <strong>Objecte visible!</strong><br>` +
              `üìç Dist√†ncia: ${Math.round(distance)} m<br>` +
              `üì¶ Posici√≥: (0, 0, ${-distance.toFixed(1)})<br>` +
              `üì° Precisi√≥ GPS: ¬±${accuracy} m`
            : `üìç Dist√†ncia: ${Math.round(distance)} m<br>` +
              `‚ö†Ô∏è Fora de rang (m√†x ${visibilityDistance}m)<br>` +
              `üì° Precisi√≥ GPS: ¬±${accuracy} m<br>` +
              `üë£ Apropa't per veure l'objecte`;
        }

        renderer.render(scene, camera);
      }

      // Funci√≥ per actualitzar la rotaci√≥ de la c√†mera segons l'orientaci√≥ del dispositiu
      function updateCameraOrientation() {
        const alpha = THREE.MathUtils.degToRad(deviceOrientation.alpha);
        const beta = THREE.MathUtils.degToRad(deviceOrientation.beta);
        const gamma = THREE.MathUtils.degToRad(deviceOrientation.gamma);
        const orient = THREE.MathUtils.degToRad(screenOrientation);

        // Crear quaternions per a cada eix de rotaci√≥
        const zee = new THREE.Vector3(0, 0, 1);
        const euler = new THREE.Euler();
        const q0 = new THREE.Quaternion();
        const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 al voltant de l'eix X

        euler.set(beta, alpha, -gamma, 'YXZ'); // Ordre d'Euler: YXZ
        camera.quaternion.setFromEuler(euler);
        camera.quaternion.multiply(q1);
        camera.quaternion.multiply(q0.setFromAxisAngle(zee, -orient));
      }
    </script>
  </body>
</html>
