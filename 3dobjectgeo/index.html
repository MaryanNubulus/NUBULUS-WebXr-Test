<!DOCTYPE html>
<html lang="ca">
  <head>
    <meta charset="UTF-8" />
    <title>AR Geolocalitzat amb Indicador</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
        font-family: sans-serif;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        z-index: 100;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 6px;
      }
      #indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 50px;
        height: 50px;
        z-index: 100;
        color: white;
        font-size: 40px;
        text-align: center;
        pointer-events: none;
      }
      .btn {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 30px;
        font-size: 18px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        z-index: 100;
        color: white;
      }
      #geoBtn {
        top: 40%;
        background: #007bff;
      }
      #camBtn {
        top: 50%;
        background: #28a745;
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="info">Prem els botons per activar AR</div>
    <div id="indicator">‚¨ÜÔ∏è</div>
    <button id="geoBtn" class="btn">Activa Geolocalitzaci√≥</button>
    <button id="camBtn" class="btn">Activa C√†mera</button>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      let scene, camera, renderer, model, video, videoTexture, videoMesh;
      let userPosition = null;
      let deviceOrientation = 0; // Orientaci√≥ del dispositiu (alpha)
      const targetLat = 41.631736995249575;
      const targetLon = 0.7782826945720215;
      const visibilityDistance = 20; // metres

      // Funci√≥ per normalitzar angles a rang 0-360
      function normalizeAngle(angle) {
        angle = angle % 360;
        if (angle < 0) angle += 360;
        return angle;
      }

      const info = document.getElementById("info");
      const indicator = document.getElementById("indicator");
      const geoBtn = document.getElementById("geoBtn");
      const camBtn = document.getElementById("camBtn");

      // --- PAS 1: Geolocalitzaci√≥ ---
      geoBtn.addEventListener("click", () => {
        // Iniciar actualitzaci√≥ cont√≠nua de posici√≥
        navigator.geolocation.watchPosition(
          (pos) => {
            userPosition = pos.coords;
            console.log(
              `üìç Posici√≥ actualitzada: ${pos.coords.latitude.toFixed(
                6
              )}, ${pos.coords.longitude.toFixed(6)}`
            );
          },
          (err) => {
            info.innerText = "Perm√≠s GPS denegat";
            console.error(err);
          },
          {
            enableHighAccuracy: true,
            maximumAge: 1000, // Acceptar dades d'1 segon enrere
            timeout: 5000,
          }
        );

        info.innerText = "Geolocalitzaci√≥ activada!";
        geoBtn.style.display = "none";
        camBtn.style.display = "block";
      });

      // --- PAS 2: C√†mera i Orientaci√≥ ---
      camBtn.addEventListener("click", async () => {
        camBtn.style.display = "none";
        info.innerText = "Iniciant c√†mera i sensors...";

        try {
          // Demanar c√†mera UNA VEGADA
          video = document.createElement("video");
          video.autoplay = true;
          video.playsInline = true;
          video.muted = true;

          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment" },
            audio: false,
          });
          video.srcObject = stream;

          // Esperar que el v√≠deo estigui llest per obtenir dimensions
          await new Promise((resolve) => {
            video.addEventListener('loadedmetadata', resolve, { once: true });
          });

          // Iniciar sensor d'orientaci√≥ (tamb√© UNA VEGADA)
          await initOrientation();

          info.innerText = "‚úÖ AR iniciada";

          initAR();
          animate();
        } catch (err) {
          info.innerText = "Error: " + err.message;
          console.error(err);
        }
      });

      // --- Sensor d'orientaci√≥ (s'executa UNA VEGADA) ---
      async function initOrientation() {
        // Per iOS 13+ cal demanar perm√≠s
        if (
          typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function"
        ) {
          try {
            const permission = await DeviceOrientationEvent.requestPermission();
            if (permission === "granted") {
              window.addEventListener("deviceorientation", handleOrientation);
              console.log("‚úÖ Sensor d'orientaci√≥ activat");
            } else {
              info.innerText += " (Orientaci√≥ denegada)";
            }
          } catch (err) {
            console.error("Error permisos orientaci√≥:", err);
          }
        } else {
          // Android i altres
          window.addEventListener("deviceorientation", handleOrientation);
          console.log("‚úÖ Sensor d'orientaci√≥ activat");
        }
      }

      // Aquest event s'executa autom√†ticament cada vegada que canvia l'orientaci√≥
      function handleOrientation(event) {
        if (event.alpha !== null) {
          deviceOrientation = event.alpha; // 0-360 graus (0 = Nord)
        }
      }

      function initAR() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          1000
        );

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Ajustar aspecte del v√≠deo segons dimensions reals
        videoTexture = new THREE.VideoTexture(video);
        const videoAspect = video.videoWidth / video.videoHeight;
        const screenAspect = window.innerWidth / window.innerHeight;
        
        let planeWidth, planeHeight;
        if (screenAspect > videoAspect) {
          planeWidth = 2 * screenAspect;
          planeHeight = 2;
        } else {
          planeWidth = 2;
          planeHeight = 2 / videoAspect;
        }
        
        const videoMaterial = new THREE.MeshBasicMaterial({
          map: videoTexture,
        });
        const videoGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        videoMesh = new THREE.Mesh(videoGeometry, videoMaterial);
        videoMesh.material.depthTest = false;
        videoMesh.material.depthWrite = false;
        videoMesh.position.z = -1;
        scene.add(videoMesh);

        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);

        const loader = new GLTFLoader();
        loader.load(
          "test.glb",
          (gltf) => {
            model = gltf.scene;
            model.scale.set(5, 5, 5); // Escala 5x m√©s gran
            model.position.set(0, 0, 0); // Posici√≥ inicial
            scene.add(model);
            console.log("‚úÖ Model GLB carregat correctament");
          },
          (progress) => {
            const percent = (progress.loaded / progress.total) * 100;
            console.log(`Carregant model: ${percent.toFixed(0)}%`);
          },
          (error) => {
            console.error("‚ùå Error carregant model GLB:", error);
            info.innerText = "Error: No s'ha pogut carregar el model 3D";
          }
        );

        window.addEventListener("resize", onWindowResize);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Reajustar aspecte del v√≠deo
        if (video && videoMesh) {
          const videoAspect = video.videoWidth / video.videoHeight;
          const screenAspect = window.innerWidth / window.innerHeight;
          
          let planeWidth, planeHeight;
          if (screenAspect > videoAspect) {
            planeWidth = 2 * screenAspect;
            planeHeight = 2;
          } else {
            planeWidth = 2;
            planeHeight = 2 / videoAspect;
          }
          
          videoMesh.geometry.dispose();
          videoMesh.geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        }
      }

      // Converteix lat/lon a metres respecte a l'usuari
      function latLonToMeters(userLat, userLon, objLat, objLon) {
        const R = 6371000;
        const dLat = ((objLat - userLat) * Math.PI) / 180;
        const dLon = ((objLon - userLon) * Math.PI) / 180;
        const latRad = (userLat * Math.PI) / 180;
        const x = dLon * R * Math.cos(latRad);
        const z = dLat * R;
        return { x, z };
      }

      function animate() {
        requestAnimationFrame(animate);

        if (userPosition && model) {
          const meters = latLonToMeters(
            userPosition.latitude,
            userPosition.longitude,
            targetLat,
            targetLon
          );
          model.position.x = meters.x;
          model.position.z = -meters.z;

          const distance = Math.sqrt(meters.x ** 2 + meters.z ** 2);
          model.visible = distance <= visibilityDistance;

          // Calcular angle absolut cap a l'objecte (bearing) en graus
          let bearing = Math.atan2(meters.x, meters.z) * (180 / Math.PI);
          bearing = normalizeAngle(bearing); // Normalitzar a 0-360

          // Normalitzar deviceOrientation tamb√©
          const normalizedOrientation = normalizeAngle(deviceOrientation);

          // Calcular angle relatiu
          let relativeAngle = bearing - normalizedOrientation;
          
          // Ajustar per evitar salts (mantenir en rang -180 a 180)
          if (relativeAngle > 180) relativeAngle -= 360;
          if (relativeAngle < -180) relativeAngle += 360;

          // Informaci√≥ de debug millorada
          const accuracy = userPosition.accuracy ? userPosition.accuracy.toFixed(1) : 'N/A';
          info.innerHTML = model.visible
            ? `‚úÖ <strong>Objecte visible!</strong><br>Dist√†ncia: ${Math.round(distance)} m`
            : `üìç Dist√†ncia: ${Math.round(distance)} m (apropa't)<br>` +
              `üß≠ Orientaci√≥: ${Math.round(normalizedOrientation)}¬∞<br>` +
              `üéØ Direcci√≥ objecte: ${Math.round(bearing)}¬∞<br>` +
              `üì° Precisi√≥ GPS: ¬±${accuracy} m`;

          // Aplicar rotaci√≥ correcta a l'indicador (ara sense doble centrat)
          indicator.style.transform = `translate(-50%, -50%) rotate(${relativeAngle}deg)`;
          indicator.style.display = model.visible ? "none" : "block";
        }

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
